name: AI PR Review

on:
  # Manual trigger from Actions tab
  workflow_dispatch:
    inputs:
      pr_url:
        description: 'Full PR URL (e.g., https://github.com/owner/repo/pull/123)'
        required: true
        type: string
      review_level:
        description: 'Review strictness level'
        required: false
        type: choice
        default: 'medium - balanced review'
        options:
          - 'critic - thorough, flags everything'
          - 'medium - balanced review'
          - 'low - critical issues only'
      review_focus:
        description: 'Review focus area'
        required: false
        type: choice
        default: 'general - all aspects'
        options:
          - 'general - all aspects'
          - 'security - vulnerabilities, auth, injection'
          - 'performance - efficiency, memory, speed'
          - 'code-quality - patterns, maintainability'
          - 'tests - coverage, assertions, edge cases'
      complementary_branch:
        description: 'Optional: complementary branch URL for cross-repo comparison (leave empty to skip)'
        required: false
        type: string
        default: ''
      search_documentation:
        description: 'Search external library documentation during review'
        required: false
        type: choice
        default: 'no - skip documentation search'
        options:
          - 'no - skip documentation search'
          - 'yes - search docs for external libraries'

  # Reusable workflow - can be called from other repos
  workflow_call:
    inputs:
      pr_url:
        description: 'Full PR URL (leave empty for auto-detect from PR event)'
        required: false
        type: string
        default: ''
      review_level:
        description: 'Review level: critic, medium, or low'
        required: false
        type: string
        default: 'medium'
      review_focus:
        description: 'Review focus: general, security, performance, code-quality, or tests'
        required: false
        type: string
        default: 'general'
      complementary_branch:
        description: 'Optional branch URL for comparison'
        required: false
        type: string
        default: ''
      search_documentation:
        description: 'Search external library documentation (yes/no)'
        required: false
        type: string
        default: 'no'
    secrets:
      GH_PAT:
        description: 'GitHub PAT with repo access'
        required: true
      DEEPSEEK_API_KEY:
        description: 'DeepSeek API key'
        required: true

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Parse PR URL
        id: parse
        run: |
          # Auto-detect from PR event or use input
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            OWNER="${{ github.repository_owner }}"
            REPO="${{ github.event.repository.name }}"
            PR_NUMBER="${{ github.event.pull_request.number }}"
            echo "ðŸ”„ Auto-detected from PR event"
          elif [ -n "${{ inputs.pr_url }}" ]; then
            PR_URL="${{ inputs.pr_url }}"
            if [[ $PR_URL =~ github\.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
              OWNER="${BASH_REMATCH[1]}"
              REPO="${BASH_REMATCH[2]}"
              PR_NUMBER="${BASH_REMATCH[3]}"
            else
              echo "âŒ Invalid PR URL format"
              exit 1
            fi
          else
            echo "âŒ No PR URL provided and not triggered by PR event"
            exit 1
          fi

          echo "owner=$OWNER" >> $GITHUB_OUTPUT
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "repo_full=$OWNER/$REPO" >> $GITHUB_OUTPUT

          echo "âœ… Parsed: $OWNER/$REPO PR #$PR_NUMBER"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.repo_full }}
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Prepare PR context
        id: pr_info
        run: |
          REPO_FULL="${{ steps.parse.outputs.repo_full }}"
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"

          PR_DATA=$(gh pr view $PR_NUMBER -R $REPO_FULL --json headRefName,baseRefName,title,body,author)
          HEAD_REF=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_REF=$(echo "$PR_DATA" | jq -r '.baseRefName')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')

          echo "Fetching branches..."
          git fetch origin $HEAD_REF
          git fetch origin $BASE_REF

          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT

          # Create review prompt file
          cat > review_prompt.md << 'PROMPT_EOF'
          You are a senior code reviewer. Review this pull request.

          PROMPT_EOF

          cat >> review_prompt.md << PROMPT_EOF
          ## PR Information
          - Repository: $REPO_FULL
          - PR Number: #$PR_NUMBER
          - Title: $PR_TITLE
          - Author: @$PR_AUTHOR
          - Base Branch: $BASE_REF
          - Head Branch: $HEAD_REF
          - Review Level: ${{ inputs.review_level }}
          - Review Focus: ${{ inputs.review_focus }}

          ## Changed Files
          PROMPT_EOF

          git diff --name-status origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo "" >> review_prompt.md
          echo "## Statistics" >> review_prompt.md
          git diff --stat origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo "" >> review_prompt.md
          echo "## Full Diff" >> review_prompt.md
          echo '```diff' >> review_prompt.md
          git diff -U5 origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo '```' >> review_prompt.md

          # === PROJECT STRUCTURE ===
          echo "" >> review_prompt.md
          echo "## Project Structure" >> review_prompt.md
          echo '```' >> review_prompt.md
          find . -type f -name "*.ts" -o -name "*.js" -o -name "*.tsx" -o -name "*.jsx" -o -name "*.py" -o -name "*.go" -o -name "*.rs" | grep -v node_modules | grep -v .git | head -100 >> review_prompt.md
          echo '```' >> review_prompt.md

          # === FULL CONTENT OF CHANGED FILES ===
          echo "" >> review_prompt.md
          echo "## Full Content of Changed Files" >> review_prompt.md
          echo "These are the complete files (not just diff) for better context:" >> review_prompt.md

          CHANGED_FILES=$(git diff --name-only origin/$BASE_REF...origin/$HEAD_REF)
          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              echo "" >> review_prompt.md
              echo "### File: \`$file\`" >> review_prompt.md
              # Detect language from extension
              ext="${file##*.}"
              echo "\`\`\`$ext" >> review_prompt.md
              cat -n "$file" >> review_prompt.md
              echo '```' >> review_prompt.md
            fi
          done

          # === RELATED/IMPORTED FILES ===
          echo "" >> review_prompt.md
          echo "## Related Files (imports/dependencies)" >> review_prompt.md
          echo "Files imported by changed files for cross-functional review:" >> review_prompt.md

          for file in $CHANGED_FILES; do
            if [ -f "$file" ]; then
              # Extract imports (JS/TS style)
              imports=$(grep -E "^import .* from ['\"]\..*['\"]" "$file" 2>/dev/null | sed -E "s/.*from ['\"]([^'\"]+)['\"].*/\1/" | sort -u)
              # Extract requires (CommonJS)
              requires=$(grep -E "require\(['\"]\..*['\"]\)" "$file" 2>/dev/null | sed -E "s/.*require\(['\"]([^'\"]+)['\"]\).*/\1/" | sort -u)

              all_imports="$imports $requires"

              for imp in $all_imports; do
                # Resolve relative path
                dir=$(dirname "$file")
                resolved="$dir/$imp"
                # Try common extensions
                for ext in "" ".ts" ".tsx" ".js" ".jsx" ".py"; do
                  if [ -f "${resolved}${ext}" ]; then
                    target="${resolved}${ext}"
                    # Skip if already in changed files
                    if ! echo "$CHANGED_FILES" | grep -q "^${target}$"; then
                      echo "" >> review_prompt.md
                      echo "### Imported by \`$file\`: \`$target\`" >> review_prompt.md
                      fext="${target##*.}"
                      echo "\`\`\`$fext" >> review_prompt.md
                      cat -n "$target" 2>/dev/null | head -200 >> review_prompt.md
                      echo '```' >> review_prompt.md
                    fi
                    break
                  fi
                done
              done
            fi
          done

          # === COMPLEMENTARY BRANCH ===
          COMP_BRANCH="${{ inputs.complementary_branch }}"
          if [ -n "$COMP_BRANCH" ]; then
            echo "" >> review_prompt.md
            echo "## Complementary Branch Reference" >> review_prompt.md
            echo "Comparing against: $COMP_BRANCH" >> review_prompt.md

            # If it's a URL, parse and fetch
            if [[ $COMP_BRANCH =~ github\.com/([^/]+)/([^/]+)/tree/([^/]+) ]]; then
              COMP_OWNER="${BASH_REMATCH[1]}"
              COMP_REPO="${BASH_REMATCH[2]}"
              COMP_REF="${BASH_REMATCH[3]}"

              echo "Fetching from $COMP_OWNER/$COMP_REPO branch $COMP_REF..." >> review_prompt.md

              # Fetch complementary branch files via GitHub API
              for file in $CHANGED_FILES; do
                content=$(gh api "repos/$COMP_OWNER/$COMP_REPO/contents/$file?ref=$COMP_REF" --jq '.content' 2>/dev/null | base64 -d 2>/dev/null)
                if [ -n "$content" ]; then
                  echo "" >> review_prompt.md
                  echo "### Complementary: \`$file\` from $COMP_REF" >> review_prompt.md
                  ext="${file##*.}"
                  echo "\`\`\`$ext" >> review_prompt.md
                  echo "$content" | head -200 >> review_prompt.md
                  echo '```' >> review_prompt.md
                fi
              done
            fi
          fi

          # === EXTERNAL LIBRARY DOCUMENTATION SEARCH ===
          SEARCH_DOCS="${{ inputs.search_documentation }}"
          if [[ "$SEARCH_DOCS" == yes* ]]; then
            echo "ðŸ“š Searching for external library documentation..."

            # Extract external package imports (not relative paths)
            EXTERNAL_PACKAGES=""
            for file in $CHANGED_FILES; do
              if [ -f "$file" ]; then
                ext="${file##*.}"

                # JavaScript/TypeScript imports
                if [[ "$ext" =~ ^(js|jsx|ts|tsx)$ ]]; then
                  # ES6 imports: import x from 'package' (not starting with . or /)
                  js_imports=$(grep -E "^import .* from ['\"][^./]" "$file" 2>/dev/null | sed -E "s/.*from ['\"]([^'\"/@]+).*/\1/" | sort -u)
                  # Require: require('package') (not starting with . or /)
                  js_requires=$(grep -E "require\(['\"][^./]" "$file" 2>/dev/null | sed -E "s/.*require\(['\"]([^'\"/@]+).*/\1/" | sort -u)
                  EXTERNAL_PACKAGES="$EXTERNAL_PACKAGES $js_imports $js_requires"
                fi

                # Python imports
                if [[ "$ext" == "py" ]]; then
                  py_imports=$(grep -E "^(import|from) [a-zA-Z]" "$file" 2>/dev/null | sed -E "s/^import ([a-zA-Z_][a-zA-Z0-9_]*).*/\1/" | sed -E "s/^from ([a-zA-Z_][a-zA-Z0-9_]*).*/\1/" | sort -u)
                  EXTERNAL_PACKAGES="$EXTERNAL_PACKAGES $py_imports"
                fi

                # Go imports
                if [[ "$ext" == "go" ]]; then
                  go_imports=$(grep -E '^\s*"[a-zA-Z]' "$file" 2>/dev/null | grep -v "^//" | sed -E 's/.*"([^"]+)".*/\1/' | grep -v "^\./" | sort -u)
                  EXTERNAL_PACKAGES="$EXTERNAL_PACKAGES $go_imports"
                fi
              fi
            done

            # Deduplicate and filter common stdlib packages
            UNIQUE_PACKAGES=$(echo "$EXTERNAL_PACKAGES" | tr ' ' '\n' | sort -u | grep -v "^$" | \
              grep -vE "^(os|sys|re|json|path|fs|http|net|fmt|time|math|util|crypto|stream|buffer|events|url|querystring|child_process|cluster|dgram|dns|domain|readline|repl|string_decoder|tls|tty|v8|vm|zlib|assert|async_hooks|inspector|perf_hooks|process|punycode|timers|trace_events|worker_threads|console)$")

            if [ -n "$UNIQUE_PACKAGES" ]; then
              echo "" >> review_prompt.md
              echo "## External Library Documentation" >> review_prompt.md
              echo "Documentation fetched for libraries used in changed files:" >> review_prompt.md

              # Limit to first 5 packages to avoid overwhelming the context
              PACKAGES_TO_SEARCH=$(echo "$UNIQUE_PACKAGES" | head -5)

              for pkg in $PACKAGES_TO_SEARCH; do
                echo "" >> review_prompt.md
                echo "### ðŸ“¦ \`$pkg\`" >> review_prompt.md

                # Try to fetch package info from npm registry (for JS packages)
                npm_info=$(curl -s "https://registry.npmjs.org/$pkg" 2>/dev/null | jq -r 'select(.name) | "**Description:** \(.description // "N/A")\n**Homepage:** \(.homepage // .repository.url // "N/A")\n**Latest Version:** \(.["dist-tags"].latest // "N/A")"' 2>/dev/null)

                if [ -n "$npm_info" ] && [ "$npm_info" != "null" ]; then
                  echo "$npm_info" >> review_prompt.md

                  # Fetch README snippet if available
                  readme=$(curl -s "https://registry.npmjs.org/$pkg" 2>/dev/null | jq -r '.readme // empty' 2>/dev/null | head -100)
                  if [ -n "$readme" ]; then
                    echo "" >> review_prompt.md
                    echo "<details><summary>ðŸ“– README excerpt</summary>" >> review_prompt.md
                    echo "" >> review_prompt.md
                    echo "$readme" | head -100 >> review_prompt.md
                    echo "" >> review_prompt.md
                    echo "</details>" >> review_prompt.md
                  fi
                else
                  # Try PyPI for Python packages
                  pypi_info=$(curl -s "https://pypi.org/pypi/$pkg/json" 2>/dev/null | jq -r 'select(.info) | "**Description:** \(.info.summary // "N/A")\n**Homepage:** \(.info.home_page // .info.project_url // "N/A")\n**Latest Version:** \(.info.version // "N/A")"' 2>/dev/null)

                  if [ -n "$pypi_info" ] && [ "$pypi_info" != "null" ]; then
                    echo "$pypi_info" >> review_prompt.md
                  else
                    echo "Documentation not found in npm or PyPI registries." >> review_prompt.md
                  fi
                fi
              done

              SKIPPED_COUNT=$(echo "$UNIQUE_PACKAGES" | wc -l)
              SEARCHED_COUNT=$(echo "$PACKAGES_TO_SEARCH" | wc -l)
              if [ "$SKIPPED_COUNT" -gt "$SEARCHED_COUNT" ]; then
                echo "" >> review_prompt.md
                echo "_Note: $(($SKIPPED_COUNT - $SEARCHED_COUNT)) additional packages were detected but not searched to limit context size._" >> review_prompt.md
              fi
            fi
          fi

          # Add review level instructions
          REVIEW_LEVEL="${{ inputs.review_level }}"

          if [[ "$REVIEW_LEVEL" == critic* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: CRITIC (Thorough)
          Focus on ALL issues including breaking changes, security vulnerabilities, bugs, logic errors, edge cases, error handling gaps, and code quality problems. Be thorough and flag everything.

          PROMPT_EOF
          elif [[ "$REVIEW_LEVEL" == low* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: LOW (Critical Only - FAST)
          FAST review mode. ONLY flag CRITICAL issues:
          - Security vulnerabilities
          - Data loss or corruption
          - Crashes or critical errors
          Skip everything else. Do NOT explore files or use todo lists. Analyze the diff directly and output findings immediately.

          PROMPT_EOF
          else
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: MEDIUM (Balanced)
          Focus on bugs, security issues, and significant code quality problems. Skip minor style issues unless they affect readability or maintainability.

          PROMPT_EOF
          fi

          # Add focus-specific instructions
          REVIEW_FOCUS="${{ inputs.review_focus }}"

          if [[ "$REVIEW_FOCUS" == security* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Focus: SECURITY
          Prioritize: SQL injection, XSS, CSRF, auth bypass, secrets exposure, insecure dependencies, input validation, privilege escalation.

          PROMPT_EOF
          elif [[ "$REVIEW_FOCUS" == performance* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Focus: PERFORMANCE
          Prioritize: N+1 queries, memory leaks, inefficient loops, blocking operations, missing caching, large payloads, unnecessary re-renders.

          PROMPT_EOF
          elif [[ "$REVIEW_FOCUS" == code-quality* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Focus: CODE QUALITY
          Prioritize: SOLID principles, DRY violations, complex conditionals, poor naming, missing abstractions, tight coupling, dead code.

          PROMPT_EOF
          elif [[ "$REVIEW_FOCUS" == tests* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Focus: TESTS
          Prioritize: Missing test coverage, weak assertions, missing edge cases, flaky tests, test isolation, mocking issues.

          PROMPT_EOF
          fi

          # Add documentation-specific instructions if enabled
          if [[ "${{ inputs.search_documentation }}" == yes* ]]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Documentation Reference
          External library documentation has been fetched. When reviewing code that uses these libraries:
          - Verify API usage matches documented signatures
          - Check for deprecated function usage
          - Validate correct parameter types and order
          - Confirm proper error handling patterns as documented
          - Flag any usage that contradicts official documentation

          PROMPT_EOF
          fi

          cat >> review_prompt.md << 'PROMPT_EOF'
          ## Review Instructions

          CROSS-FUNCTIONAL REVIEW: You have access to:
          1. Full content of changed files (not just diff) - use this to understand context
          2. Related/imported files - verify changed code correctly uses functions from dependencies
          3. Project structure - understand the codebase architecture
          4. Complementary branch (if provided) - compare implementations
          5. External library documentation (if enabled) - verify correct API usage

          When reviewing imports/usage, CHECK that:
          - Function signatures match between caller and callee
          - Types are compatible
          - Required parameters are provided
          - Return values are handled correctly

          Output GitHub markdown. Use this EXACT format for each issue:

          ---

          ### ðŸ”´ CRITICAL `filename:line-range`

          **Original Code:**
          ```javascript
          27 | const hash = hashPassword(password);
          28 | console.log('Hash:', hash);
          ```

          **Problem:** Async function not awaited, returns Promise instead of value.

          **Suggested Fix:**
          ```javascript
          27 | const hash = await hashPassword(password);
          28 | console.log('Hash:', hash);
          ```

          ---

          IMPORTANT: Always include "**Original Code:**" and "**Suggested Fix:**" labels before each code block.

          Severities: ðŸ”´ CRITICAL, âš ï¸ WARNING, â„¹ï¸ INFO, ðŸ’¡ SUGGESTION
          End with: **Verdict:** APPROVE | REQUEST_CHANGES | COMMENT
          If no issues: "âœ… No issues found" and APPROVE
          PROMPT_EOF

          echo "Review prompt created:"
          wc -l review_prompt.md
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Install opencode
        run: curl -fsSL https://opencode.ai/install | bash

      - name: Run review with opencode
        id: review
        run: |
          export PATH="$HOME/.opencode/bin:$PATH"

          # Run opencode with JSON format to extract final response
          opencode run "$(cat review_prompt.md)" --model deepseek/deepseek-chat --format json 2>&1 | tee review_raw.json || true

          # Extract text responses and find the one containing the review (has "Summary" section)
          grep '"type":"text"' review_raw.json | while read -r line; do
            text=$(echo "$line" | jq -r '.part.text // empty')
            if echo "$text" | grep -q "## Summary"; then
              echo "$text" > review_output.md
              break
            fi
          done

          # Fallback: get the last text response if no Summary found
          if [ ! -s review_output.md ]; then
            grep '"type":"text"' review_raw.json | tail -1 | \
              jq -r '.part.text // empty' > review_output.md 2>/dev/null || true
          fi

          # Clean up: ensure file has content
          if [ ! -s review_output.md ]; then
            echo "Review generation failed - no output captured" > review_output.md
          fi

          echo "Review completed"
          echo "--- Review Output Preview ---"
          head -50 review_output.md
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}

      - name: Post review comment
        run: |
          REPO_FULL="${{ steps.parse.outputs.repo_full }}"
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"

          # Count existing AI reviews to generate review number
          REVIEW_COUNT=$(gh pr view $PR_NUMBER -R $REPO_FULL --json comments --jq '[.comments[] | select(.body | contains("# ðŸ¤– Code Review #"))] | length')
          REVIEW_NUM=$((REVIEW_COUNT + 1))

          # Build docs indicator
          DOCS_INDICATOR=""
          if [[ "${{ inputs.search_documentation }}" == yes* ]]; then
            DOCS_INDICATOR=" | **Docs:** ðŸ“š enabled"
          fi

          # Add header with review number
          {
            echo "# ðŸ¤– Code Review #${REVIEW_NUM}"
            echo ""
            echo "> **Level:** ${{ inputs.review_level || 'medium' }} | **Focus:** ${{ inputs.review_focus || 'general' }}${DOCS_INDICATOR}"
            echo ""
            echo "---"
            echo ""
          } > final_review.md
          # Combine header with review output
          cat review_output.md >> final_review.md

          # Post as PR comment
          gh pr comment $PR_NUMBER -R $REPO_FULL --body-file final_review.md

          echo "âœ… Code Review #$REVIEW_NUM posted to PR #$PR_NUMBER"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
