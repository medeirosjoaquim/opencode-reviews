name: Manual PR Review

on:
  workflow_dispatch:
    inputs:
      pr_url:
        description: 'Full PR URL (e.g., https://github.com/owner/repo/pull/123)'
        required: true
        type: string
      review_level:
        description: 'Review strictness level'
        required: false
        type: choice
        default: 'medium'
        options:
          - critic
          - medium
          - low

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Parse PR URL
        id: parse
        run: |
          PR_URL="${{ inputs.pr_url }}"

          if [[ $PR_URL =~ github\.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
            OWNER="${BASH_REMATCH[1]}"
            REPO="${BASH_REMATCH[2]}"
            PR_NUMBER="${BASH_REMATCH[3]}"

            echo "owner=$OWNER" >> $GITHUB_OUTPUT
            echo "repo=$REPO" >> $GITHUB_OUTPUT
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "repo_full=$OWNER/$REPO" >> $GITHUB_OUTPUT

            echo "âœ… Parsed: $OWNER/$REPO PR #$PR_NUMBER"
          else
            echo "âŒ Invalid PR URL format"
            exit 1
          fi

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse.outputs.repo_full }}
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Prepare PR context
        id: pr_info
        run: |
          REPO_FULL="${{ steps.parse.outputs.repo_full }}"
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"

          PR_DATA=$(gh pr view $PR_NUMBER -R $REPO_FULL --json headRefName,baseRefName,title,body,author)
          HEAD_REF=$(echo "$PR_DATA" | jq -r '.headRefName')
          BASE_REF=$(echo "$PR_DATA" | jq -r '.baseRefName')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.author.login')

          echo "Fetching branches..."
          git fetch origin $HEAD_REF
          git fetch origin $BASE_REF

          echo "head_ref=$HEAD_REF" >> $GITHUB_OUTPUT
          echo "base_ref=$BASE_REF" >> $GITHUB_OUTPUT

          # Create review prompt file
          cat > review_prompt.md << 'PROMPT_EOF'
          You are a senior code reviewer. Review this pull request.

          PROMPT_EOF

          cat >> review_prompt.md << PROMPT_EOF
          ## PR Information
          - Repository: $REPO_FULL
          - PR Number: #$PR_NUMBER
          - Title: $PR_TITLE
          - Author: @$PR_AUTHOR
          - Base Branch: $BASE_REF
          - Head Branch: $HEAD_REF
          - Review Level: ${{ inputs.review_level }}

          ## Changed Files
          PROMPT_EOF

          git diff --name-status origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo "" >> review_prompt.md
          echo "## Statistics" >> review_prompt.md
          git diff --stat origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo "" >> review_prompt.md
          echo "## Full Diff" >> review_prompt.md
          echo '```diff' >> review_prompt.md
          git diff -U5 origin/$BASE_REF...origin/$HEAD_REF >> review_prompt.md
          echo '```' >> review_prompt.md

          # Add review level instructions
          REVIEW_LEVEL="${{ inputs.review_level }}"

          if [ "$REVIEW_LEVEL" = "critic" ]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: CRITIC (Strict)
          Focus on ALL issues including breaking changes, security vulnerabilities, bugs, logic errors, edge cases, error handling gaps, and code quality problems. Be thorough and flag everything that could cause issues.

          PROMPT_EOF
          elif [ "$REVIEW_LEVEL" = "low" ]; then
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: LOW (Critical Only)
          ONLY flag issues that are CRITICAL to the PR's objective. Ignore minor problems, style issues, and medium-severity bugs. Focus exclusively on:
          - Security vulnerabilities that could be exploited
          - Data loss or corruption risks
          - Breaking changes that affect the PR's main goal
          - Crashes or critical runtime errors
          Skip everything else - no style suggestions, no minor improvements.

          PROMPT_EOF
          else
            cat >> review_prompt.md << 'PROMPT_EOF'

          ## Review Level: MEDIUM (Balanced)
          Focus on bugs, security issues, and significant code quality problems. Skip minor style issues unless they affect readability or maintainability.

          PROMPT_EOF
          fi

          cat >> review_prompt.md << 'PROMPT_EOF'
          ## Review Instructions

          Output a GitHub markdown formatted review. Use this EXACT format for each issue:

          ---

          ### âš ï¸ WARNING `filename:line`

          **Problem:** Brief explanation of the issue.

          ```javascript
          const hash = hashPassword(password); // âŒ Missing await - returns Promise not value
          ```

          ```suggestion
          const hash = await hashPassword(password);
          ```

          ---

          Use these severity headers:
          - `### ðŸ”´ CRITICAL` - Security vulnerabilities, data loss, crashes
          - `### âš ï¸ WARNING` - Bugs, logic errors, missing error handling
          - `### â„¹ï¸ INFO` - Code style, naming, minor improvements
          - `### ðŸ’¡ SUGGESTION` - Optional enhancements

          Rules:
          1. First show the PROBLEMATIC code with inline // comment explaining what's wrong
          2. Then show a ```suggestion block with the FIXED code (clean, no comments)
          3. Use appropriate language hint (```javascript, ```typescript, ```python, etc.)
          4. Use `---` horizontal rules between issues
          5. Use inline code for `file:line` references
          6. End with: **Verdict:** APPROVE | REQUEST_CHANGES | COMMENT
          7. If no issues: "âœ… No issues found" and APPROVE
          8. Keep Problem explanation to 1 sentence
          PROMPT_EOF

          echo "Review prompt created:"
          wc -l review_prompt.md
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Install opencode
        run: curl -fsSL https://opencode.ai/install | bash

      - name: Run review with opencode
        id: review
        run: |
          export PATH="$HOME/.opencode/bin:$PATH"

          # Run opencode with JSON format to extract final response
          opencode run "$(cat review_prompt.md)" --model deepseek/deepseek-chat --format json 2>&1 | tee review_raw.json || true

          # Extract text responses and find the one containing the review (has "Summary" section)
          grep '"type":"text"' review_raw.json | while read -r line; do
            text=$(echo "$line" | jq -r '.part.text // empty')
            if echo "$text" | grep -q "## Summary"; then
              echo "$text" > review_output.md
              break
            fi
          done

          # Fallback: get the last text response if no Summary found
          if [ ! -s review_output.md ]; then
            grep '"type":"text"' review_raw.json | tail -1 | \
              jq -r '.part.text // empty' > review_output.md 2>/dev/null || true
          fi

          # Clean up: ensure file has content
          if [ ! -s review_output.md ]; then
            echo "Review generation failed - no output captured" > review_output.md
          fi

          echo "Review completed"
          echo "--- Review Output Preview ---"
          head -50 review_output.md
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}

      - name: Post review comment
        run: |
          REPO_FULL="${{ steps.parse.outputs.repo_full }}"
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"

          # Read review output and post as PR comment
          gh pr comment $PR_NUMBER -R $REPO_FULL --body-file review_output.md

          echo "âœ… Review posted to ${{ inputs.pr_url }}"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
